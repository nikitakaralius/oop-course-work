\chapter{Реализация функционала} \label{ch2}

\section{Реализазция интерфейса взаимодействия с файловой системой} \label{ch2:sec1}

Для реализации воспользуемся нововведением C++ 17 – библиотекой \verb|filesystem|. В реализации \verb|FileEntry|, используя функции \verb|fs::path(path).filename()|. \verb|fs::file_size(path)|, \verb|fs::last_write_time(path)| можем получить все необходимые данные о файле. В \verb|DirectoryEntry| сделаем то же самое, кроме получения размера – здесь нам понадобится рекурсивно обойти все файлы в текущем и дочерних каталогах, посчитав их суммарный размер. Проблема, однако, возникнет с получением времени, а конкретно с преобразованием его в тип \verb|time_t|. Оно необходимо, чтобы не создавать зависимость от типов библиотеки \verb|filesystem|. Само преобразование достаточно громоздкое, поэтому определим protected метод \verb|toTimeT()| в \verb|IFileSystemEntry|, который затем будем использовать в классах наследниках.

В \verb|DirectoryEntry| осталось реализовать методы \verb|files()| и \verb|subdirectories()|. Используя функции из \verb|filesystem|, получим данные о путях к файлам и директориям, преобразуем их в \verb|DirectoryEntry| и \verb|FileEntry| соответственно. Dернем \verb|std::vector|, состоящий из указателей на эти объекты.


\section{Реализация CQRS библиотеки} \label{ch2:sec2}

По умолчанию для некоторых интерфейсов представим стандартные реализации. 

\verb|MiddlewarePipeline| - конвейер обработки, содержащий вектор указателей на \verb|IMiddleware|, позволяющий добавлять в него новые объекты \verb|IMiddleware.| В нем создадим деструктор, который будет очищать все \verb|IMiddleware|. Добавим метод \verb|use(IMiddleware* middleware)|, который будет добавлять в \verb|std::vector| \verb|middleware|. Реализуем метод \verb|IResponse* process(IRequest& request)|, который будет поэтапно вызывать все слои конвейера. Для этого нам понадобится воспользоваться функциональным объектом \verb|std::function|, чтобы собрать вместе всю цепочку вызовов.

В \verb|RequestHandler| \verb|handleRequest()| будем получать обработчик из роутера, передавать ему запрос и возвращать полученный ответ, не забывая почистить обработчик из памяти по завершении.

\verb|RequestSender| использует \verb|RequestHandler|, вызывая у него \verb|handleRequest(request)| и передавая туда объект запроса.

\section{Реализация инфраструктурных сервисов} \label{ch2:sec3}

Начнем с самого основного – \verb|Application|. В конструкторе будем принимать указатели на объекты \verb|RequestHandler| и \verb|IUserInteractor|, а также будем создавать \verb|MiddlewarePipeline|. Все эти объекты будут храниться в полях для их дальнейшего удаления в деструкторе. Метод \verb|use(IMiddleware* middleware)| будет выступать в качестве прокси для \verb|MiddlewarePipeline| для добавления нового middleware. В методе \verb|run()| организуем цикл, пока не поступит команда от пользователя в \verb|userInteractor|, что надо выйти . Внутри цикла будем считывать пользовательский запрос с \verb|userInteractor|, затем будем передавать его в \verb|middlewarePipeline| и получать результат. В конце цикла очищаем запрос и ответ.

Также по заданию нам понадобится выводить историю о событиях в файл. Для этого создадим класс \verb|FileLogger|, реализующий \verb|ILogger|. В методе \verb|log| при помощи \verb|ofstream| будем записывать информацию в файл, путь к которому будем указывать через конструктор класса. 

Для удобства отладки нам может пригодиться выводить эту информацию не только в файл, но и в консоль. Поэтому создадим класс \verb|ConsoleLogger|, который будет записывать переданную информацию через \verb|сout|.

Для обоих этих классов определим \verb|Middleware|. Создадим класс \verb|LoggerMiddleware|, реализующий \verb|IMiddleware|, который будет содержать указатель на logger. В начале метода \verb|.invoke()| он будет выводить информацию о запросе через метод \verb|.toString()|, затем будет получать запрос, выводя его через логер, под конец возвращать результат в виде полученного запроса. Создадим также \verb|ConsoleLoggerMiddleware| и \verb|FileLoggerMiddleware|, в которых сразу в конструкторе будем передавать нужный объект логера.

Не уходя далеко от \verb|Middleware|, напишем промежуточный слой, который будет обрабатывать ошибки. Здесь в блоке \verb|try| будем вызывать следующий \verb|middleware|, и если где-то в процессе обработки произошла ошибка, будем ловить ее в блоках \verb|catch|, создавая \verb|ExceptionResponse|, который добавим в проект чуть позже.

В классе \verb|ApplicationRequestRouter|, реализующим \verb|IRequestRouter| будем при помощи \verb|dynamic_cast| преобразовывать запросы. Если преобразование успешное, будем возвращать соответствующий обработчик. Если такого обработчика не нашлось – выбрасываем исключение. К сожалению, этот класс придется править каждый раз, как будет появляться новый обработчик.

Последнее и самое грязное, что нам осталось – это \verb|ConsoleUserInteractor|. Сюда поэтапно будем добавлять различные способы считывания пользовательского ввода. В методе \verb|readRequest| будем выводить меню с командами, а затем при помощи конструкции \verb|switch| и пользовательского ввода выбирать нужный запрос.

\section{Связывание компонентов системы} \label{ch2:sec4}

В конце останется только связать все написанные компоненты. Перейдем в main, вызовем \verb|create()| у \verb|ApplicationBuilder| и через методы \verb|add| добавим \verb|ApplicationRequestRouter| и \verb|ConsoleUserInteractor|. Вызовем метод \verb|build|, чтобы создать объект \verb|Application|.

Созданный объект назовем app. У него надо добавить middleware, при этом важен порядок добавления:

\begin{enumerate}
	\item \verb|ConsoleLoggerMiddleware|.
	\item \verb|FileLoggerMiddleware|.
	\item \verb|ExceptionHandlingMiddleware| (обязательно должен идти после Middleware c логированием, иначе информация об ошибках писаться не будет).
\end{enumerate}

В конце метода main не забываем отчистить память, удалив app. Возвращаем статус код 0.

%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы